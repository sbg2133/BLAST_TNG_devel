# This software contains functions that may be useful for analyzing the I/Q stream generated by the BLAST-TNG firmware. 
#
# Copyright (C) 2016  Gordon, Sam <sbgordo1@asu.edu>
# Author: Gordon, Sam <sbgordo1@asu.edu>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os,sys
import numpy as np
import scipy.stats as stats
from scipy.signal import argrelextrema
import matplotlib
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt
from scipy import optimize
from scipy import signal
from scipy import interpolate
import peakutils
from detect_peaks import detect_peaks
y_formatter = matplotlib.ticker.ScalarFormatter(useOffset=False)

class pipeline(object):
    
    def __init__(self):
        
        self.path = '/mnt/iqstream'
        self.option = 'vna_sweeps'
        self.select = 'scaled2'
        #self.vna_path = 'vna_sweeps'
        #self.target_path = 'target_sweeps'
        self.datapath = os.path.join(self.path, self.option,self.select)        
        #print self.datapath
        data_files=[f for f in sorted(os.listdir(self.datapath)) if f.endswith('.npy')]
        I = np.array([np.load(os.path.join(self.datapath,f)) for f in data_files if f.startswith('I')])
        Q = np.array([np.load(os.path.join(self.datapath,f)) for f in data_files if f.startswith('Q')])
        self.lo_freqs = np.array([np.float(f[1:-4]) for f in data_files if f.startswith('I')])
        #print f
        self.chan_ts = I + 1j*Q
        self.nchan = len(self.chan_ts[0])
        self.cm = plt.cm.spectral(np.linspace(0.05,0.95,self.nchan))
        self.i = self.chan_ts.real
        self.q = self.chan_ts.imag
        self.mag = np.abs(self.chan_ts)
        self.phase = np.angle(self.chan_ts)
        self.centers=self.loop_centers(self.chan_ts) # returns self.centers
        self.chan_ts_centered = self.chan_ts - self.centers
        self.rotations = np.angle(self.chan_ts_centered[self.chan_ts_centered.shape[0]/2])
        self.chan_ts_rotated = self.chan_ts_centered * np.exp(-1j*self.rotations)
        self.phase_rotated = np.angle(self.chan_ts_rotated)
        #self.ts_off = np.load(os.path.join(self.datapath,'timestreams/I750.27.npy')) + 1j*np.load(os.path.join(self.datapath,'timestreams/Q750.27.npy'))
        #self.ts_on = np.load(os.path.join(self.datapath,'timestreams/I750.57.npy')) + 1j*np.load(os.path.join(self.datapath,'timestreams/Q750.57.npy'))
        #self.ts_on_centered = self.ts_on - self.centers
        #self.ts_on_rotated = self.ts_on_centered *np.exp(-1j*self.rotations)
        self.bb_freqs=np.load(os.path.join(self.path,'last_bb_freqs.npy'))
        #self.i_off, self.q_off = self.ts_off.real, self.ts_off.imag
        #self.i_on, self.q_on = self.ts_on_rotated.imag, self.ts_on_rotated.imag
        #self.phase_off = np.angle(self.ts_off)    
        #self.phase_on = np.angle(self.ts_on_rotated)    
        #self.kid_freqs=np.load(os.path.join(self.path,'last_kid_freqs.npy'))
        #self.bb_freqs=np.load(os.path.join(self.path,'last_bb_freqs.npy'))
        #self.rf_freqs=np.load(os.path.join(self.path,'last_rf_freqs.npy'))
        self.delta_lo = 2.5e3
        
    def phase_scatter(self,chan):
        fig = plt.figure()
        plt.suptitle('Phase scatter, Channel = ' + str(chan))
        plot1 = plt.subplot(1,2,1)
        plot1.scatter(self.i_off[:,chan], self.q_off[:,chan], color = 'b', label = 'off res')    
        plot1.scatter(self.i_on[:,chan], self.q_on[:,chan], color = 'r', label = 'on res')
        plt.xlabel('I')
        plt.ylabel('Q')
        plot1.set_autoscale_on(True)
        off_data = sorted(self.phase_off[:,chan])
        on_data = sorted(self.phase_on[:,chan])
        fwhm_off = np.abs(np.round(2.355*np.std(self.phase_off[:,chan]),3))
        fwhm_on = np.abs(np.round(2.355*np.std(self.phase_on[:,chan]),3))
        off_fit = stats.norm.pdf(off_data, np.mean(self.phase_off[:,chan]), np.std(self.phase_off[:,chan]))
        on_fit = stats.norm.pdf(on_data, np.mean(self.phase_on[:,chan]), np.std(self.phase_on[:,chan]))
        plot2 = plt.subplot(1,2,2)
        plot2.plot(off_data - np.mean(off_data), off_fit, color = 'b', label = 'fwhm off = '+ str(fwhm_off))
        plot2.plot(on_data - np.mean(on_data), on_fit, color = 'r', label = 'fwhm on = '+ str(fwhm_on))
        plt.xlabel('rad')
        plt.ylabel('Prob. Density')
        plt.legend()
        plt.show()
        return
    
    def delta_f(self, channel):    
        i_index = [np.where(np.abs(np.diff(self.i[:,chan])) == np.max(np.abs(np.diff(self.i[:,chan]))))[0][0] for chan in range(self.nchan)]
        q_index = [np.where(np.abs(np.diff(self.q[:,chan])) == np.max(np.abs(np.diff(self.q[:,chan]))))[0][0] for chan in range(self.nchan)]
        self.di_df = np.array([(self.i[:,chan][i_index[chan] + 1] - self.i[:,chan][i_index[chan] - 1])/(2*self.delta_lo) for chan in range(self.nchan)])
        self.dq_df = np.array([(self.q[:,chan][q_index[chan] + 1] - self.q[:,chan][q_index[chan] - 1])/(2*self.delta_lo) for chan in range(self.nchan)])
        self.delta_i_on = [self.i_on[:,chan] - np.mean(self.i_on[:,chan]) for chan in range(self.nchan)] 
        self.delta_q_on = [self.q_on[:,chan] - np.mean(self.q_on[:,chan]) for chan in range(self.nchan)] 
        self.delta_i_off = [self.i_off[:,chan] - np.mean(self.i_off[:,chan]) for chan in range(self.nchan)] 
        self.delta_q_off = [self.q_off[:,chan] - np.mean(self.q_off[:,chan]) for chan in range(self.nchan)] 
        self.df_on = [ ((self.delta_i_on[chan] * self.di_df[chan]) + (self.delta_q_on[chan] * self.dq_df[chan]) / (self.di_df[chan]**2 + self.dq_df[chan]**2)) for chan in range(self.nchan)]
        self.df_off = [ ((self.delta_i_off[chan] * self.di_df[chan]) + (self.delta_q_off[chan] * self.dq_df[chan]) / (self.di_df[chan]**2 + self.dq_df[chan]**2)) for chan in range(self.nchan)]
        time = np.arange(0, len(self.i_off))/244.
        frequ = np.arange(1, len(self.i_off)+1)*244./len(self.i_off)
        plt.plot(np.log10(frequ), np.log10((np.abs(np.fft.fft(self.df_off[channel]/self.kid_freqs[channel])))**2/len(self.i_off)), label = r'$\Delta$f off', color = 'black')
        plt.plot(np.log10(frequ), np.log10((np.abs(np.fft.fft(self.df_on[channel]/self.kid_freqs[channel])))**2/len(self.i_off)), label = r'$\Delta$f on', color = 'red', alpha = 0.5)
        #plt.plot(self.df_off[channel], color = 'b', label = 'off')
        #plt.plot(self.df_on[channel], color= 'g', label = 'on')
        plt.title(r'$\Delta$f, Channel = ' + str(channel))
        plt.xlabel('log$_{10}$ freq (Hz)')
        plt.ylabel(r'log$_{10}$ (ef/f$_{0}$)$^{2}$ (Hz)')
        plt.legend()
        plt.show()
        return 

    def loop_centers(self,timestream):
        def least_sq_circle_fit(chan):
            """
            Least squares fitting of circles to a 2d data set. 
            Calcultes jacobian matrix to speed up scipy.optimize.least_sq. 
            Complements to scipy.org
            Returns the center and radius of the circle ((xc,yc), r)
            """
            #x=self.i[:,chan]
            #y=self.q[:,chan]
            x=timestream[:,chan].real
            y=timestream[:,chan].imag
            xc_guess = x.mean()
            yc_guess = y.mean()
                        
            def calc_radius(xc, yc):
                """ calculate the distance of each data points from the center (xc, yc) """
                return np.sqrt((x-xc)**2 + (y-yc)**2)
    
            def f(c):
                """ calculate f, the algebraic distance between the 2D points and the mean circle centered at c=(xc, yc) """
                Ri = calc_radius(*c)
                return Ri - Ri.mean()
    
            def Df(c):
                """ Jacobian of f.The axis corresponding to derivatives must be coherent with the col_deriv option of leastsq"""
                xc, yc = c
                dfdc = np.empty((len(c), x.size))
                Ri = calc_radius(xc, yc)
                dfdc[0] = (xc - x)/Ri            # dR/dxc
                dfdc[1] = (yc - y)/Ri            # dR/dyc
                dfdc = dfdc - dfdc.mean(axis=1)[:, np.newaxis]
                return dfdc
        
            (xc,yc), success = optimize.leastsq(f, (xc_guess, yc_guess), Dfun=Df, col_deriv=True)
        
            Ri = calc_radius(xc,yc)
            R = Ri.mean()
            residual = sum((Ri - R)**2) #error in fit if needed
            #print xc_guess,yc_guess,xc,yc
            return (xc,yc),R

        centers=[]
        for chan in range(self.nchan):
                (xc,yc),r = least_sq_circle_fit(chan)
                centers.append(xc+1j*yc)
        #self.centers = np.array(centers)
        return np.array(centers)

    def plot_loop_centered(self,chan):
        plt.plot(self.chan_ts_centered.real[:,chan],self.chan_ts_centered.imag[:,chan],'x',color=self.cm[chan])
        plt.gca().set_aspect('equal')
        plt.xlim(np.std(self.chan_ts_centered.real[:,chan])*-3,np.std(self.chan_ts_centered.real[:,chan]*3))
        plt.ylim(np.std(self.chan_ts_centered.imag[:,chan])*-3.,np.std(self.chan_ts_centered.imag[:,chan]*3))
        plt.show()
        return

    def plot_loop_rotated(self,chan):
        plt.figure(figsize = (20,20))
        plt.title('IQ loop Channel = ' + str(chan) + ', centered and rotated')
        plt.plot(self.chan_ts_rotated.real[:,chan],self.chan_ts_rotated.imag[:,chan],'x',color='red',mew=2, ms=6)
        plt.gca().set_aspect('equal')
        plt.xlim(np.std(self.chan_ts_rotated.real[:,chan])*-3,np.std(self.chan_ts_rotated.real[:,chan])*3)
        plt.ylim(np.std(self.chan_ts_rotated.imag[:,chan])*-3,np.std(self.chan_ts_rotated.imag[:,chan])*3)
        plt.xlabel('I')
        plt.ylabel('Q')
        plt.show()
        return

    def multiplot(self, chan):
        #for chan in range(self.nchan):
        colormap = plt.cm.BuGn
        attens = np.arange(20., 32., 1)
        gradient = np.linspace(0.3, 1.0, len(attens))
        fig,axs = plt.subplots(1,3)
        for atten in attens:
            datapath = os.path.join(self.path,self.option,str(atten))
            print datapath   
            data_files=[f for f in sorted(os.listdir(datapath)) if f.endswith('.npy')]
            I = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('I')])
            Q = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('Q')])
            lo_freqs = np.array([np.float(f[1:-4]) for f in data_files if f.startswith('I')])
            chan_ts = I + 1j*Q
            mag = np.abs(chan_ts)
            centers=self.loop_centers(chan_ts) # returns self.centers
            chan_ts_centered = chan_ts - centers #self.centers are calculated for -20 dBm attenuation
            rotations = np.angle(chan_ts_centered[chan_ts_centered.shape[0]/2])
            chan_ts_rotated = chan_ts_centered * np.exp(-1j*rotations)
            phase_rotated = np.angle(chan_ts_rotated)
            
            rf_freq = self.bb_freqs[chan] + lo_freqs

            #plt.figure(figsize=(24,8))
            #plt.subplot(131)
            axs[0].plot(rf_freq/1e6,10*np.log10(mag[:,chan]),'b', linewidth = 3, color = colormap(gradient[np.where(attens == atten)][0]), label =str(atten))
            #plt.xlabel('Frequency [MHz]', fontsize = 20)
            #ax.grid()
        
            #plt.subplot(132)
            axs[1].plot(rf_freq/1e6,phase_rotated[:,chan],'b',linewidth = 3, color = colormap(gradient[np.where(attens == atten)][0]), label =str(atten))
            #plt.xlabel('Frequency [MHz]', fontsize = 20)
            #ax.grid()
      
            #plt.subplot(133)
            axs[2].plot(chan_ts_rotated[:,chan].real,chan_ts_rotated[:,chan].imag,'b',marker='x', linewidth = 2, color = colormap(gradient[np.where(attens == atten)][0]), label =str(atten))
            axs[2].axis('equal')            
        
        axs[2].legend(loc = 'lower left', fontsize = 15)
        plt.grid()            
        plt.savefig(os.path.join(self.datapath,'psd%04drotated.png'%chan), bbox = 'tight')
        plt.show()         
        plt.clf()
        print ' plotting ',chan,;sys.stdout.flush()
        return
        
    def multiplot2(self, chan):
        #for chan in range(self.nchan):
        rf_freqs = np.load(os.path.join(self.datapath,'light_kids.npy'))
        rf_freq= rf_freqs[chan] - (np.max(rf_freqs) + np.min(rf_freqs))/2. + self.lo_freqs
        print np.shape(rf_freq)
        print np.shape(self.mag)
        fig,axs = plt.subplots(1,3)
        axs[0].plot(rf_freq/1e6,10*np.log10(self.mag[:,chan]),'b', linewidth = 3)

        axs[1].plot(rf_freq/1e6,self.phase_rotated[:,chan],'b',linewidth = 3)

        axs[2].plot(self.chan_ts_rotated[:,chan].real,self.chan_ts_rotated[:,chan].imag,'b',marker='x', linewidth = 2)
        axs[2].axis('equal')                    
        axs[2].legend(loc = 'lower left', fontsize = 15)
        plt.grid()            
        plt.savefig(os.path.join(self.datapath,'multiplot%04drotated.png'%chan), bbox = 'tight')
        plt.show()         
        plt.clf()
        print ' plotting ',chan,;sys.stdout.flush()
        return
       
       
    def vna_comp(self):
        path = '/mnt/iqstream/'
        option = 'vna_sweeps'
        select = 'scaled2'
        datapath = os.path.join(path, option, select)        
        data_files=[f for f in sorted(os.listdir(datapath)) if f.endswith('.npy')]
        Ion = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('I')])
        Qon = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('Q')])
        lo_freqs = np.array([np.float(f[1:-4]) for f in data_files if f.startswith('I')])
        select = 'scalednocover'
        datapath = os.path.join(path, option, select)        
        data_files=[f for f in sorted(os.listdir(datapath)) if f.endswith('.npy')]
        Ioff = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('I')])
        Qoff = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('Q')])
        chan_ts_on = Ion + 1j*Qon
        chan_ts_off = Ioff + 1j*Qoff
        mag_on = chan_ts_on
	mag_off = chan_ts_off
	scaled_mags_on = np.zeros((np.shape(mag_on)[1],len(lo_freqs)))
	scaled_mags_off = np.zeros((np.shape(mag_on)[1],len(lo_freqs)))
	for chan in range(np.shape(mag_on)[1]):
		diff = 0. - np.mean(mag_on[:,chan])
		scaled_mags_on[chan] = diff + mag_on[:,chan]
		diff = 0. - np.mean(mag_off[:,chan])
		scaled_mags_off[chan] = diff + mag_off[:,chan]        
        bb_freqs, delta_f = np.linspace(-200.0e6, 200.0e6, 500,retstep=True)
        bb_freqs = np.roll(bb_freqs, - np.argmin(np.abs(bb_freqs)) - 1)
        center_freq=750.0e6
        rf_freqs = bb_freqs + center_freq
        channels = np.arange(len(rf_freqs))
        span=delta_f
        start = center_freq - (span/2.)
        stop = center_freq + (span/2.) 
        step = 5e3
        sweep_freqs = np.arange(start, stop, step)
        sweep_freqs = np.round(sweep_freqs/step)*step
#        full_freqs = (sweep_freqs + bb_freqs[0])/1.0e9
#        full_mag_off = mag_off[:,0]/np.abs(mag_off[:,0].mean())
#        full_mag_on = mag_on[:,0]/np.abs(mag_on[:,0].mean())
#        for chan in np.arange(len(rf_freqs)-1):
#            full_freqs=np.append(full_freqs,(sweep_freqs + bb_freqs[chan+1])/1.0e9)
#            full_mag_off=np.append(full_mag_off,mag_off[:,chan]/np.abs(mag_off[:,chan+1].mean()))
#            full_mag_on=np.append(full_mag_on,mag_on[:,chan]/np.abs(mag_on[:,chan+1].mean()))
#        #plt.plot(full_freqs,20*np.log10(full_mag_on/full_mag_off))
#        plt.plot(full_freqs,20*np.log10(full_mag_on))
#        plt.plot(full_freqs,20*np.log10(full_mag_off))
        #[ plt.plot((sweep_freqs + bb_freqs[chan])/1.0e9,20*np.log10((mag_off[:,chan]/np.abs(mag_off[:,chan].mean()))/(mag_on[:,chan]/np.abs(mag_on[:,chan].mean())))) for chan in channels]
        [ plt.plot((sweep_freqs + bb_freqs[chan])/1.0e9,20*np.log10(chan_ts_off[:,chan]/chan_ts_on[:,chan]),color='blue', alpha = 0.8) for chan in channels]
       # [ plt.plot((sweep_freqs + bb_freqs[chan])/1.0e9,20*np.log10(scaled_mags_on[chan]),color='red',) for chan in channels]
        plt.xlabel('Frequency (GHz)')
        plt.ylabel('20log (S21 mag) [dB]')
        plt.title('temp chop')
        #plt.savefig(os.path.join(save_path,'fig.png'))
        plt.show()
   
    def open_stored(self, path):
	files = sorted(os.listdir(path))
	sweep_freqs = np.array([np.float(filename[1:-4]) for filename in files if (filename.startswith('I'))])
	I_list = [os.path.join(path, filename) for filename in files if filename.startswith('I')]
	Q_list = [os.path.join(path, filename) for filename in files if filename.startswith('Q')]
	Is = np.array([np.load(filename) for filename in I_list])
	Qs = np.array([np.load(filename) for filename in Q_list])
	return sweep_freqs, Is, Qs
    
    def plot_vna_sweep(self, path):
	bb_freqs = np.linspace(-255.0e6, 255.0e6, 1000)
	#bb_freqs = np.linspace(-200.0e6, 200.0e6, 500)
	#bb_freqs = np.load('/media/lazarus/UNTITLED/iqstream/last_bb_freqs.npy')
	lo_freqs, Is, Qs = self.open_stored(path)
	channels = np.arange(np.shape(Is)[1])
	mags = np.zeros((len(channels),len(lo_freqs)))
	scaled_mags = np.zeros((len(channels),len(lo_freqs)))
	for chan in channels:
        	mags[chan] = 20*np.log10(np.sqrt(Is[:,chan]**2 + Qs[:,chan]**2)) 
		diff = 0. - np.mean(mags[chan])
		scaled_mags[chan] = diff + mags[chan]
		plt.plot((lo_freqs + bb_freqs[chan])/1.0e9,scaled_mags[chan])
	plt.xlabel('Frequency (GHz)')
        plt.ylabel('20log(mag) [dB]')
        plt.show()
        return
	
    def butter_bandpass(self, lowcut, highcut, fs, order=5):
    	nyq = 0.5 * fs
        low = lowcut / nyq
	high = highcut / nyq
	b, a = butter(order, [low, high], btype='band')
	return b, a
   
    def butter_bandpass_filter(self, data, lowcut, highcut, fs, order=5):
    	b, a = self.butter_bandpass(lowcut, highcut, fs, order=order)
        y = signal.filter(b, a, data)
        return y
   
    def find_kids_vna(self, path, plot_chan = False, plot_sweep = False):
	bb_freqs = np.linspace(-255.0e6, 255.0e6, 1000)
	lo_freqs, Is, Qs = self.open_stored(path)
	channels = np.arange(np.shape(Is)[1])
	chan_freqs = np.zeros((len(channels),len(lo_freqs)))
	#bb_freqs, freq_step = np.linspace(-200.0e6, 200.0e6, 500, retstep = True)
	rf_freqs = np.sort(bb_freqs + 750.0e6)
	mags = np.zeros((len(channels),len(lo_freqs)))
	scaled_mags = np.zeros((len(channels),len(lo_freqs)))
	chan_peaks = []
	peak_idx = []
	for chan in channels:
		mags[chan] = 20*np.log10(np.sqrt(Is[:,chan]**2 + Qs[:,chan]**2)) 
		diff = 0. - np.mean(mags[chan])
		scaled = diff + mags[chan]
		chan_freqs[chan] = np.sort(lo_freqs + bb_freqs[chan])
		#plt.plot(chan_freqs[chan]/1.0e9, scaled_mags[chan])
		x = chan_freqs[chan]
		chan_data = np.abs(scaled) - np.max(scaled) 
		scaled_mags[chan] = chan_data
		#thresh = np.mean(ydata) + np.std(ydata)
		thresh = np.max(scaled) - 0.7*np.max(scaled)
		upper_thresh = thresh + 0.5*np.std(chan_data)
		window = signal.hanning(3)
		chan_data_smoothed = signal.convolve(chan_data,signal.hanning(3), mode = 'same')
		peaks = detect_peaks(chan_data, mph = thresh, mpd = np.round(50.0e3/2.5e3))
		if len(peaks) > 0:
			for peak in peaks:
				if not ((thresh + 0.5 < chan_data[peak])):
					peaks = np.delete(peaks,np.where(peaks == peak)[0])
			if len(peaks) > 3:
				for peak in peaks:
					peaks = np.delete(peaks,np.where(chan_data[peaks] == np.min(chan_data[peaks]))[0])
			#if len(peaks) == 3:
				#for peak in peaks: 
				#	if not chan_data[peak] > upper_thresh:	
				#		peaks = np.delete(peaks,np.where(chan_data[peaks] == np.min(chan_data[peaks]))[0])
		if len(peaks) > 0:
			for peak in peaks:
				peak_idx.append(peak + 205*chan)	

		if plot_chan:
			if len(peaks) > 0:
				plt.plot(x/1.0e9, chan_data, c='g')
				plt.scatter(x[peaks]/1.0e9, chan_data[peaks], c='r')
				#plt.scatter(x/1.0e9, chan_data, c='g')
				plt.axhline(thresh, c = 'b', linestyle = '--')
				plt.title('Chan = ' + str(chan))
				plt.ylabel('Mag (dB)')
				plt.xlabel('Freq (GHz)')
				plt.ion()
				plt.show()	
				raw_input()
				plt.clf()
			else:
				pass
	peak_idx = np.hstack(peak_idx)
	print 'Located', len(peak_idx), 'detectors'  
	if plot_sweep:
		scaled_mags = np.hstack(scaled_mags)
		chan_freqs = np.hstack(chan_freqs)
		plt.figure(figsize = (18,10))
		plt.plot(chan_freqs/1.0e9, scaled_mags, c='g')
		#[plt.axvline(chan_freqs[205*chan]/1.0e9) for chan in channels]
		plt.scatter(chan_freqs[peak_idx]/1.0e9, scaled_mags[peak_idx], c='r')
		plt.axhline(thresh, c = 'b', linestyle = '--')
		plt.ylabel('Mag (dB)')
		plt.xlabel('Freq (GHz)')
		plt.show()
	return peak_idx, chan_freqs, scaled_mags	

    def peakFinder(self,mags):
        n = len(mags)
        middleIndex = n/2
        middleIsMax = mags[middleIndex] > mags[middleIndex + 1] and mags[middleIndex] > mags[middleIndex - 1]

        # base case 
        if middleIsMax:
            return mags[middleIndex]

        leftArray = mags[:middleIndex]
        rightArray = mags[middleIndex:]

        moveRight = mags[middleIndex + 1] >= mags[middleIndex] and mags[middleIndex + 1] >= mags[middleIndex - 1]

        moveLeft = mags[middleIndex - 1] >= mags[middleIndex] and mags[middleIndex - 1] >= mags[middleIndex + 1]

        # recursive case
        if moveRight:
            return self.peakFinder(rightArray)
        elif moveLeft:
            return self.peakFinder(leftArray)
    
    def plot_comp(self, on_path, off_path):
	lo_freqs, I_on, Q_on = self.open_stored('/mnt/iqstream/vna_sweeps/scaled2')
	lo_freqs, I_off, Q_off = self.open_stored('/mnt/iqstream/vna_sweeps/scalednocover')
	bb_freqs, delta_f = np.linspace(-200.0e6, 200.0e6, 500,retstep=True)
	#bb_freqs = np.load('/mnt/iqstream/last_bb_freqs.npy')
	channels = len(bb_freqs)
        delta_lo = 5e3
	i_index = [np.where(np.abs(np.diff(I_on[:,chan])) == np.max(np.abs(np.diff(I_on[:,chan]))))[0][0] for chan in np.arange(channels)]
        q_index = [np.where(np.abs(np.diff(Q_on[:,chan])) == np.max(np.abs(np.diff(Q_on[:,chan]))))[0][0] for chan in np.arange(channels)]
        self.di_df = np.array([(I_on[:,chan][i_index[chan] + 1] - I_on[:,chan][i_index[chan] - 1])/(2*delta_lo) for chan in np.arange(channels)])
        self.dq_df = np.array([(Q_on[:,chan][q_index[chan] + 1] - Q_on[:,chan][q_index[chan] - 1])/(2*delta_lo) for chan in np.arange(channels)])
	self.delta_I = [I_on[:,chan] - I_off[:,chan] for chan in np.arange(channels)]	
	self.delta_Q = [Q_on[:,chan] - Q_off[:,chan] for chan in np.arange(channels)]	
        self.df = [ ((self.delta_I[chan] * self.di_df[chan]) + (self.delta_Q[chan] * self.dq_df[chan]) / (self.di_df[chan]**2 + self.dq_df[chan]**2)) for chan in np.arange(channels)]

	self.rf_freqs = [lo_freqs + bb_freqs[chan] for chan in np.arange(channels)]
	self.rf_freqs = np.hstack(self.rf_freqs)
	
	for chan in np.arange(channels):
		threshold = np.min(self.df[chan])
		self.df[chan][self.df[chan] > threshold] = 0.
			
	self.df_reshape = np.hstack(self.df)
	self.df_reshape[self.df_reshape > -12*np.std(self.df_reshape)] = 0.
	#self.df_reshape[self.df_reshape > -9000] = 0.
	self.kid_idx = np.where(self.df_reshape != 0.)[0]
	self.light_freqs = self.rf_freqs[self.kid_idx]
	lo_freqs, mags_on = self.open_stored_mags(on_path)
	lo_freqs, mags_off = self.open_stored_mags(off_path)
	
	fig, (ax1, ax2) = plt.subplots(2,1,'none', figsize = (20, 20))
	[ax1.plot((lo_freqs + bb_freqs[chan])/1.0e9,mags_on[chan], color = 'blue') for chan in np.arange(channels)]
	[ax1.plot((lo_freqs + bb_freqs[chan])/1.0e9,mags_off[chan], color = 'red', alpha = 0.8) for chan in np.arange(channels)]
	[ax2.plot((lo_freqs + bb_freqs[chan])/1.0e9, self.df[chan]) for chan in np.arange(channels)]
	
	plt.grid()
	plt.show()
	return
    
    def phase_response(self):
        colormap = plt.cm.OrRd
        attens = np.arange(19., 23., 1)
        gradient = np.linspace(0.3, 1.0, len(attens))
        fig, ax = plt.subplots(figsize = (20, 20))
        chan = int(raw_input('chan #?'))
        for atten in attens:
            #ax.set_color_cycle(colormap(atten))
            path = '/mnt/iqstream'
            option = 'target_sweeps'
            datapath = os.path.join(path,option,str(atten))
            data_files=[f for f in sorted(os.listdir(datapath)) if f.endswith('.npy')]
            I = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('I')])
            Q = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('Q')])
            lo_freqs = np.array([np.float(f[1:-4]) for f in data_files if f.startswith('I')])
            chan_ts = I + 1j*Q
            nchan = len(chan_ts[0])
            i = chan_ts.real
            q = chan_ts.imag
            mag = np.abs(chan_ts)
            phase = np.angle(chan_ts)
            self.loop_centers() # returns self.centers
            chan_ts_centered = chan_ts - self.centers
            rotations = np.angle(chan_ts_centered[chan_ts_centered.shape[0]/2])
            chan_ts_rotated = chan_ts_centered * np.exp(-1j*rotations)
            phase_rotated = np.angle(chan_ts_rotated)
            
            rf_freq = self.bb_freqs[chan] + lo_freqs
            ax.plot(rf_freq/1.0e6,phase_rotated[:,chan], linewidth = 3, color = colormap(gradient[np.where(attens == atten)][0]), label =str(atten))
            #ax.plot(rf_freq/1.0e6,chan_ts_rotated[:,chan], linewidth = 3, color = colormap(gradient[np.where(attens == atten)][0]), label =str(atten))
        ax.set_title('Chan ' + str(chan) + ' Phase response vs Input Atten (dB)')
        ax.tick_params(axis='y', labelsize=20)
        ax.tick_params(axis='x', labelsize=20)
        ax.set_xlabel('Frequency [MHz]', fontsize = 20)
        ax.set_ylabel('Phase [rad]', fontsize = 20)
        ax.legend(loc = 'lower left', fontsize = 20)
        plt.grid()
        plt.show()
        return
  
    def atten_loops(self):
        colormap = plt.cm.OrRd
        attens = np.arange(19., 23., 1)
        gradient = np.linspace(0.3, 1.0, len(attens))
        fig, ax = plt.subplots(figsize = (20, 20))
        chan = int(raw_input('chan #?'))
        for atten in attens:
            print chan      
            #ax.set_color_cycle(colormap(atten))
            path = '/mnt/iqstream'
            option = 'target_sweeps'
            datapath = os.path.join(path,option,str(atten))
            data_files=[f for f in sorted(os.listdir(datapath)) if f.endswith('.npy')]
            I = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('I')])
            Q = np.array([np.load(os.path.join(datapath,f)) for f in data_files if f.startswith('Q')])
            lo_freqs = np.array([np.float(f[1:-4]) for f in data_files if f.startswith('I')])
            chan_ts = I + 1j*Q
            nchan = len(chan_ts[0])
            i = chan_ts.real
            q = chan_ts.imag
            mag = np.abs(chan_ts)
            phase = np.angle(chan_ts)
            self.loop_centers() # returns self.centers
            chan_ts_centered = chan_ts - self.centers
            rotations = np.angle(chan_ts_centered[chan_ts_centered.shape[0]/2])
            chan_ts_rotated = chan_ts_centered * np.exp(-1j*rotations)
            phase_rotated = np.angle(chan_ts_rotated)            
            rf_freq = self.bb_freqs[chan] + lo_freqs
            ax.plot(chan_ts_rotated.real[:,chan], chan_ts_rotated.imag[:,chan], linewidth = 3, color = colormap(gradient[np.where(attens == atten)][0]), label =str(atten))
        ax.set_title('Chan ' + str(chan) + ' IQ Loop vs Input Atten (dB)')
        ax.tick_params(axis='y', labelsize=20)
        ax.tick_params(axis='x', labelsize=20)
        ax.set_xlabel('I', fontsize = 20)
        ax.set_ylabel('Q', fontsize = 20)
        ax.legend(loc = 'lower left', fontsize = 20)
        ax.axis('equal')
        plt.grid()
        plt.show()
        return

    def plot_phase_psd(self,chan):
        sig_on_mag = np.abs(self.ts_on[:,chan])
        sig_off_mag = np.abs(self.ts_off[:,chan])
        sig_on = self.ts_on_rotated[:,chan]
        sig_off = self.ts_off[:,chan]
        nsamples = len(sig_on)
        time = 60.
        sample_rate = nsamples/time
        time,delta_t = np.linspace(0,time,nsamples,retstep=True)
        freq,delta_f = np.linspace(0,sample_rate/2.,nsamples/2+1,retstep=True)
        rf_freq = self.bb_freqs[chan]+self.lo_freqs

        halfway = len(self.lo_freqs)/2
        plt.figure(figsize=(14,12))
        plt.subplot(421)
        plt.gca().yaxis.set_major_formatter(y_formatter)
        plt.gca().xaxis.set_major_formatter(y_formatter)
        plt.plot(rf_freq/1e6,10*np.log10(self.mag[:,chan]),'r',label='swept magnitude')
        plt.plot(np.ones(len(sig_on_mag))*(self.bb_freqs[chan]+self.lo_freqs[halfway])/1e6,10*np.log10(sig_on_mag),'black',label='on res')
        plt.plot(np.ones(len(sig_on_mag))*(self.bb_freqs[chan]+self.lo_freqs[halfway]-300e3)/1e6,10*np.log10(sig_off_mag),'b.',label='off res')
        plt.xlabel('Sweep Frequency [MHz]')
        plt.ylabel('10log$_{10}$(|S21|) [dB]')
        plt.legend(loc = 'center',fontsize = 'small')
        plt.grid()

        plt.subplot(423)
        plt.gca().yaxis.set_major_formatter(y_formatter)
        plt.gca().xaxis.set_major_formatter(y_formatter)
        plt.plot(rf_freq/1e6,self.phase_rotated[:,chan],'r',label='swept phase')
        plt.plot(np.ones(len(sig_on_mag))*(self.bb_freqs[chan]+self.lo_freqs[halfway])/1e6,np.angle(sig_on),'black',label='on res')
        plt.plot(np.ones(len(sig_on_mag))*(self.bb_freqs[chan]+self.lo_freqs[halfway]-300e3)/1e6,np.angle(sig_off),'b.',label=' off res')
        plt.xlabel('Sweep Frequency [MHz]')
        plt.ylabel('Phase: arctan(Q/I) [dB]')
        plt.legend(loc='center',fontsize='small')
        plt.grid()
        plt.subplot(222)
        plt.gca().set_aspect('equal','datalim')
        plt.gca().yaxis.set_major_formatter(y_formatter)
        plt.plot(self.chan_ts_rotated[:,chan].real,self.chan_ts_rotated[:,chan].imag,'r',marker='x',label='swept IQ loop')
        plt.plot(sig_on.real, sig_on.imag,'black',label='on res')
        plt.plot(sig_off.real,sig_off.imag,'b',label='off res')
        plt.xlabel('I [arb. units]')
        plt.ylabel('Q [arb. units]')
        plt.legend(loc='lower left',fontsize='small')
        plt.grid()

        plt.subplot(212)
        psd_on  = delta_t/nsamples*np.abs(np.fft.rfft(np.angle(sig_on)))**2
        psd_off = delta_t/nsamples*np.abs(np.fft.rfft(np.angle(sig_off)))**2
        plt.loglog(freq,psd_on,'r',label='noise on')
        plt.loglog(freq,psd_off,'black',alpha = 0.5, label='noise off')
        plt.xlim(0.01,200)
        plt.ylim(1e-13,1e-3)
        plt.xlabel('Freq [Hz]')
        plt.ylabel(r'PSD [rad$^{2}$ / Hz]')
        plt.legend()
        plt.grid()
        plt.tight_layout()
        plt.subplots_adjust(top=0.95)
        plt.suptitle('Blast-TNG 250um array   2016-01-31   Channel %03d/%d'%(chan,self.nchan),fontsize='large')
        plt.show()
        return


    def main(self):
        #self.phase_response()
        #self.multiplot(0)
        #self.vna_comp()
        #self.plot_phase_psd(0)
        #for chan in range(self.nchan):
        #    self.multiplot2(chan)
        #self.multiplot2(44)        
        #self.plot_comp('/mnt/iqstream/vna_sweeps/scaled2', '/mnt/iqstream/vna_sweeps/scalednocover')
	return

if __name__=='__main__':
    p = pipeline()
    p.main()
